     1                                  bits 32
     2                                  global start        
     3                                  
     4                                  extern exit               
     5                                  import exit msvcrt.dll    
     6                                  
     7                                  segment data use32 class=data
     8 00000000 87                          A db 10000111b
     9 00000001 00                          B db 0
    10 00000002 00000000                    C dd 0
    11 00000006 00                          n db 0
    12                                  ;Se da octetul A. Sa se obtina numarul intreg n reprezentat de bitii 2-4 ai lui A. Sa se obtina apoi in B octetul ;rezultat prin rotirea spre dreapta a lui A cu n pozitii. Sa se obtina dublucuvantul C:
    13                                  ;bitii 8-15 ai lui C sunt 0
    14                                  ;bitii 16-23 ai lui C coincid cu bitii lui B
    15                                  ;bitii 24-31 ai lui C coincid cu bitii lui A
    16                                  ;bitii 0-7 ai lui C sunt 1
    17                                  segment code use32 class=code
    18                                      start:
    19                                          ;Sa se obtina numarul intreg n reprezentat de bitii 2-4 ai lui A
    20 00000000 A0[00000000]                    mov AL, [A]     ; AL = 10000111b
    21 00000005 241C                            and AL, 00011100b   ; izolam bitii 2-4
    22                                                              ; AL = 0000 0100b
    23 00000007 A2[06000000]                    mov [n], AL  ; n = 0000 0100b = 4
    24                                          ;mov BL, [n]
    25                                          ;add BL, 4
    26                                          ;mov [n], BL
    27                                          
    28                                          ;Sa se obtina apoi in B octetul ;rezultat prin rotirea spre dreapta a lui A cu n pozitii
    29 0000000C A0[00000000]                    mov AL, [A]     ; AL = 1000 0111b
    30 00000011 8A0D[06000000]                  mov CL, [n]
    31 00000017 D2C8                            ror AL, CL     ; rotim spre dreapta AL cu n = 4 pozitii
    32                                                          ; AL = 0111 1000b
    33 00000019 A2[01000000]                    mov [B], AL     ; B = 0111 1000b
    34                                          
    35                                          ;bitii 8-15 ai lui C sunt 0
    36 0000001E 8325[02000000]00                and dword[C], 00000000000000000000000000000000b    ; bitii 8-15 ai lui C sunt 0
    37                                          
    38                                          ;bitii 16-23 ai lui C coincid cu bitii lui B
    39 00000025 A0[01000000]                    mov AL, [B]     ; AL = 0111 1000b
    40 0000002A B400                            mov AH, 0       ; conversie fara semn de la AL la AX
    41 0000002C 66BA0000                        mov DX , 0      ; conversie fara semn de la AX la DX:AX
    42 00000030 6650                            push AX
    43 00000032 6652                            push DX
    44 00000034 58                              pop EAX         ; EAX = DX:AX
    45                                                          ; EAX = 0000 0000 0000 0000 0000 0000 0111 1000b
    46 00000035 C1E010                          shl EAX, 16     ; shfitam cu 16 pozitii spre stanga pentru ca bitii 0-7 din EAX(bitii octetului B) sa ajunga 
    47                                                          ; pe pozitiile 16-23
    48                                                          ; EAX = 0000 0000 0111 1000 0000 0000 0000 0000b
    49                                          ;and EAX, 00000000111111110000000000000000b  ;izolam bitii 16-23 
    50 00000038 0905[02000000]                  or [C], EAX     ; bitii 16-23 ai lui C coincid cu bitii 16-23 ai lui EAX(cu bitii octetului B)
    51                                          
    52                                          ;bitii 24-31 ai lui C coincid cu bitii lui A
    53 0000003E A0[00000000]                    mov AL, [A]     ; AL = 1000 0111b
    54 00000043 B400                            mov AH, 0       ; conversie fara semn de la AL la AX
    55 00000045 66BA0000                        mov DX, 0       ; conversie fara semn de la AX la DX:AX
    56 00000049 6650                            push AX
    57 0000004B 6652                            push DX
    58 0000004D 58                              pop EAX         ; EAX = DX:AX 
    59                                                          ; EAX = 0000 0000 0000 0000 0000 0000 1000 0111b
    60 0000004E C1E018                          shl EAX, 24     ; shiftam cu 24 de pozitii spre stanga pentru ca bitii 0-7 din EAX(bitii octetului A)
    61                                                          ; sa ajunga pe pozitiile 24-31
    62                                          ;and EAX, 11111111000000000000000000000000b   ; izolam bitii 24-31
    63 00000051 250000FF00                      and EAX, 00000000111111110000000000000000b
    64 00000056 0905[02000000]                  or [C], EAX     ; bitii 24-31 ai lui C coincid cu bitii 24-31 ai lui EAX(bitii octetului A)
    65                                          
    66                                          ;bitii 0-7 ai lui C sunt 1
    67 0000005C 810D[02000000]FF00-             or dword[C], 00000000000000000000000011111111b    ; bitii 0-7 ai lui C devin 1
    67 00000064 0000               
    68                                          
    69                                          
    70 00000066 6A00                            push    dword 0      
    71 00000068 FF15[00000000]                  call    [exit]       
